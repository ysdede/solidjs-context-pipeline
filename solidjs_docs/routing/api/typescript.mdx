---
source_repo: solid-docs
source_path: solid-docs\src\routes\configuration\typescript.mdx
domain: routing
extracted_at: "2026-02-01T15:19:26.813Z"
---

---
source_repo: solid-docs
source_path: solid-docs\src\routes\configuration\typescript.mdx
domain: unknown
extracted_at: "2026-02-01T15:19:26.813Z"
---

---
title: TypeScript
use_cases: >-
  type safety, code reliability, large projects, team collaboration, api
  documentation, migrating from javascript
tags:
  - typescript
  - types
  - migration
  - configuration
  - jsx
  - development
  - tooling
version: '1.0'
description: >-
  Learn to configure TypeScript with SolidJS for enhanced type safety, better
  IDE support, and reliable component development.
---

[TypeScript](https://www.typescriptlang.org/) is a superset of JavaScript that enhances code reliability and predictability through the introduction of [static types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html).
While JavaScript code can be directly used in TypeScript, the added type annotations in TypeScript provide clearer code structure and documentation, making it more accessible for developers.

By leveraging standard JSX, a syntax extension to JavaScript, Solid facilitates seamless TypeScript interpretation.
Moreover, Solid has built-in types for the API that heighten accuracy.

For developers eager to get started, we offer [TypeScript templates](https://github.com/solidjs/templates/) on GitHub.

## Configuring TypeScript

When integrating TypeScript with the Solid JSX compiler, there are some settings to make for a seamless interaction:

1. `"jsx": "preserve"` in the `tsconfig.json` retains the original JSX form.
   This is because Solid's JSX transformation is incompatible with TypeScript's JSX transformation.
2. `"jsxImportSource": "solid-js"` designates Solid as the source of JSX types.

For a basic setup, your `tsconfig.json` should resemble:

```json
{
	"compilerOptions": {
		"jsx": "preserve",
		"jsxImportSource": "solid-js"
	}
}
```

For projects with diverse JSX sources, such as a blend of React and Solid, some flexibility exists.
While it's possible to set a default `jsxImportSource` in the `tsconfig.json`, which will correspond with the majority of your files, TypeScript also allows file-level overrides.
Using specific pragmas within `.tsx` files facilitates this:

```jsx
/** @jsxImportSource solid-js */
```

or, if using React:

```jsx
/** @jsxImportSource react */
```

Opting for the React JSX pragma means having React and its associated dependencies fully integrated into the project.
Additionally, it makes sure the project's architecture is primed for React JSX file handling, which is vital.

## Migrating from JavaScript to TypeScript

Transitioning from JavaScript to TypeScript in a Solid project offers the benefits of static typing. To migrate to TypeScript:

1. Install TypeScript into your project.

```package-install-dev
typescript
```

2. Run the following command to generate a `tsconfig.json` file.


```package-exec
tsc --init
```

3. Update the contents of the `tsconfig.json` to match Solid's configuration:

```json
{
	"compilerOptions": {
		"strict": true,
		"target": "ESNext",
		"module": "ESNext",
		"moduleResolution": "node",
		"allowSyntheticDefaultImports": true,
		"esModuleInterop": true,
		"jsx": "preserve",
		"jsxImportSource": "solid-js",
		"types": ["vite/client"],
		"noEmit": true,
		"isolatedModules": true
	}
}
```

4. Create a TypeScript or `.tsx` file to test the setup.

```typescript
import { type Component } from "solid-js";

const MyTsComponent: Component = () => {
	return (
		
			<h1>This is a TypeScript component</h1>
		
	);
}

export default MyTsComponent;
```

If using an existing JavaScript component, import the TypeScript component:

```jsx
import MyTsComponent from "./MyTsComponent";

function MyJsComponent() {
	return (
		<>
			{/* ... */}
			
		</>
	);
}
```

:::note
If you wish to change the entry point file from `index.jsx` to `index.tsx`, you need to modify the `src` attribute in `<script>` to look like the following:

```html
<!doctype html>
<html lang="en">
	<head>
		<!-- ... -->
	</head>
	<body>
		<noscript>You need to enable JavaScript to run this app.</noscript>
		
		<script src="/src/index.tsx" type="module"></script>
	</body>
</html>
```

:::

## API types

Solid is written in TypeScript, meaning everything is typed out of the box.

The Reference Tab in the sidebar provides the API Documentation that details the types of API calls.
In addition, there are several helpful definitions to make it easier for specifying explicit types.

### Signals

Using `createSignal; // ❌: Children aren't expected
```

#### Components with props

For components that require the use of props, they can be typed using [generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content):

```tsx
const InitCounter: Component<{ initial: number }> = (props) => {
	const [count, setCount] = createSignal(props.initial);
	return (
		<button onClick={() => setCount((prev) => prev + 1)}>{count()}</button>
	);
};

;
```

#### Components with children

Often, components may need to accept child elements.
For this, Solid provides `ParentComponent`, which includes `children?` as an optional prop.
If defining a component with the `function` keyword, `ParentProps` can be used as a helper for the props:

```tsx
import { ParentComponent } from "solid-js";

const CustomCounter: ParentComponent = (props) => {
	const [count, setCount] = createSignal(0);
	return (
		<button onClick={() => setCount((prev) => prev + 1)}>
			{count()}
			{props.children}
		</button>
	);
};
```

In this example, `props` is inferred to be of the type `{children?: JSX.Element }`, streamlining the process of defining components that can accept children.

#### Special component types

Solid offers subtypes for components dealing uniquely with children:

- **VoidComponent:** When a component should not accept children.
- **FlowComponent:** Designed for components like [`
	
);
```

In this case, using optional chaining serves as an good alternative:

```tsx
return {user()?.name};

// Using `
	
);
```

This approach is similar to using the keyed option, but offers an accessor to prevent the recreation of children each time the `when` value changes.

```tsx
return (
	
		
	
);
```

Note that optional chaining may not always be possible.
For instance, when a `UserPanel` component exclusively requires a `User` object:

```tsx
return ;
//                        ^ Type 'undefined' is not assignable to type 'User'.
```

If possible, consider refactoring `UserPanel` to accept `undefined`.
This minimizes the changes required when `user` goes from `undefined` to `User`.

Otherwise, using Show's callback form works:

```tsx
return (
	
);
```

Casting can also be a solution so long as the assumption is valid:

```tsx
return {user() && (user() as User).name};
```

It's worth noting that runtime type errors may arise from doing this.
This may happen when passing a type-cast value to a component, which discards information that may be nullish followed by accessing it asynchronously, such as in an event handler or timeout, or in `onCleanup`.

`;
```

The following alternative also works when using `Show`:

```tsx

```

## Advanced JSX attributes and directives

### Custom event handlers

To handle custom events in Solid, you can use the attribute `on:___`.
Typing these events requires an extension of Solid's JSX namespace.

```tsx
class NameEvent extends CustomEvent {
	type: "Name";
	detail: { name: string };

	constructor(name: string) {
		super("Name", { detail: { name } });
	}
}

declare module "solid-js" {
	namespace JSX {
		interface CustomEvents {
			Name: NameEvent; // Matches `on:Name`
		}
	}
}

// Usage
 console.log("name is", event.detail.name)} />;
```

:::note
New in v1.9.0
:::

It is now possible to use the intersection `EventListenerObject & AddEventListenerOptions` to provide listener options as follows:

```tsx
import type { JSX } from "solid-js"

const handler: JSX.EventHandlerWithOptions<HTMLDivElement, Event> =  {
	once: true,
	handleEvent: (event) => {
		console.log("will fire only once");
	},
}

// Usage
;
```

:::note
**Note**:
By default, using native events like `mousemove` with the `on` prefix — for example, ` {}} />` — will trigger a TypeScript error.
This occurs because these native events are not part of Solid's custom event type definitions.
To solve this, the `CustomEvents` interface can be extended to include events from the `HTMLElementEventMap`:

To include all native events:

```ts
declare module "solid-js" {
	namespace JSX {
		interface CustomEvents extends HTMLElementEventMap {}
	}
}
```

To include specific native events, you can choose certain events (e.g. `mousemove` and `pointermove`):

```ts
declare module "solid-js" {
	namespace JSX {
		interface CustomEvents
			extends Pick<HTMLElementEventMap, "mousemove" | "pointermove"> {}
	}
}
```

:::

#### Forcing properties and custom attributes

In Solid, the `prop:___` directive allows explicit property setting, which is useful for retaining the original data types like objects or arrays.
`attr:___` directive allows custom attributes, on the other hand, and it is effective for handling string-based HTML attributes.

```ts
declare module "solid-js" {
  namespace JSX {
    interface ExplicitProperties {
      count: number;
      name: string;
    }
    interface ExplicitAttributes {
      count: number;
      name: string;
    }
    interface ExplicitBoolAttributes {
      disabled: boolean;
    }
  }
}

// Usage

<my-web-component attr:name={name()} attr:count={count()} bool:disabled={true}/>
```

#### Custom directives

In Solid, custom directives can be applied using the `use:___` attribute, which usually accepts a target element and a JSX attribute value.
The traditional `Directives` interface types these values directly (i.e. the type of `value` in ``).
However, the newer `DirectiveFunctions` interface takes a function type and derives the valid types for elements and values from it.

There are additional considerations:

- The directive function always receives a single accessor.
  For multiple arguments, the syntax `` is an option, and an accessor to a tuple should be accepted.
- The same principle holds for boolean directives, as seen in ``, and for directives with static values, like ``.
- `DirectiveFunctions` can accept functions that do not strictly meet the type requirements; such cases will be ignored.

```tsx
function model(
	element: Element, // directives can be used on any HTML and SVG element
	value: Accessor<Signal<string>> // second param will always be an accessor in case value being reactive
) {
	const [field, setField] = value();
	createRenderEffect(() => (element.value = field()));
	element.addEventListener("input", (e) => {
		const value = (e.target as HTMLInputElement).value;
		setField(value);
	});
}

declare module "solid-js" {
	namespace JSX {
		interface Directives {
			model: Signal<string>; // Corresponds to `use:model`
		}
	}
}

// Usage
let [name, setName] = createSignal("");
<input type="text" use:model={[name, setName]} />;
```

In using `DirectiveFunctions`, there's the ability to check both arguments (if present) by detailing the entire function type:

```tsx
function model(element: HTMLInputElement, value: Accessor<Signal<string>>) {
	const [field, setField] = value();
	createRenderEffect(() => (element.value = field()));
	element.addEventListener("input", (e) => setField(e.target.value));
}

function log(element: Element) {
	console.log(element);
}

let num = 0;
function count() {
	num++;
}

function foo(comp: Element, args: Accessor<string[]>) {
	// function body
}

declare module "solid-js" {
	namespace JSX {
		interface DirectiveFunctions {
			model: typeof model;
			log: typeof log;
			count: typeof count;
			foo: typeof foo;
		}
	}
}
```

While the `Directives` interface can limit the value type passed via JSX attribute to the directive, the `DirectiveFunctions` interface ensures that both element and value align with the expected types, as shown below:

```tsx
{/* This is correct */}
<input use:model={createSignal('')} />

{/* These will result in a type error */}
<input use:model />
<input use:model={7} />

```

##### Addressing import issues with directives

If directives are imported from a separate file or module, TypeScript might mistakenly remove the import thinking it is a type.

To prevent this:

- Configure `onlyRemoveTypeImports: true` in `babel-preset-typescript`.
- When using `vite-plugin-solid`, set `solidPlugin({ typescript: { onlyRemoveTypeImports: true } })` in `vite.config.ts`.

Careful management of export type and import type is required.
Including a statement in the importing module ensures TypeScript keeps the directive's import.
[Tree-shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) tools usually omit this code from the final bundle.

```tsx
import { directive } from "./directives.js"

directive // prevents TypeScript's tree-shaking


```