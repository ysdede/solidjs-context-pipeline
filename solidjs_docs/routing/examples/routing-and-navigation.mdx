---
source_repo: solid-docs
source_path: solid-docs\src\routes\guides\routing-and-navigation.mdx
domain: routing
extracted_at: "2026-02-01T15:19:26.810Z"
---

---
source_repo: solid-docs
source_path: solid-docs\src\routes\guides\routing-and-navigation.mdx
domain: unknown
extracted_at: "2026-02-01T15:19:26.810Z"
---

---
title: Routing & navigation
order: 4
use_cases: >-
  page navigation, url routing, spa routing, dynamic routes, nested layouts,
  route parameters, lazy loading pages
tags:
  - routing
  - navigation
  - routes
  - spa
  - lazy-loading
  - parameters
  - layouts
version: '1.0'
description: >-
  Implement client-side routing in Solid apps with dynamic routes, nested
  layouts, route parameters, and lazy-loaded components.
---

[Solid Router](/solid-router) simplifies routing in Solid applications to help developers manage navigation and rendering by defining routes using JSX or objects passed via props.

## Getting started

**1. Install the router**

This package is not included by default.

```package-install
@solidjs/router
```

**2. Setup the `
	),
	document.getElementById("root")
);
```

**5. Create a CatchAll route (404 page)**

A catchall route can be used for pages not found at any nested level of the router.
Using `*` will retrieve the rest of the path.
Optionally, you can also add a parameter name.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import NotFound from "./pages/NotFound";

const App = (props) => (
	<>
		<h1>Site Title</h1>
		{props.children}
	</>
);

render(
	() => (
		
	),
	document.getElementById("root")
);
```

**6. Create links to your routes**

The [`
			
		</nav>
		<h1>Site Title</h1>
		{props.children}
	</>
);

render(
	() => (
		
	),
	document.getElementById("root")
);
```

## Lazy-loading route components

The [`lazy`](/reference/component-apis/lazy) function postpones the loading of a component until it is navigated to.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const Home = lazy(() => import("./pages/Home"));

const App = (props) => (
	<>
		<h1>Site Title</h1>
		{props.children}
	</>
);

render(
	() => (
		
	),
	document.getElementById("root")
);
```

## Dynamic routes

If a path is unknown ahead of time, you can treat part of the path as a flexible parameter.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const User = lazy(() => import("./pages/User"));
const Home = lazy(() => import("./pages/Home"));

render(
	() => (
		
	),
	document.getElementById("root")
);
```

The colon indicates that `id` can be any string, and as long as the URL fits that pattern, the `
```

### Accessing parameters

In cases where you may need to access a dynamic route's parameters within your components, the [`useParams`](/solid-router/reference/primitives/use-params) primitive is available.
Once the parameters have been accessed using `useParams`, they can be used within your component:

```jsx
import { useParams } from "@solidjs/router";

const User = () => {
	const params = useParams(); // Retrieve the dynamic route parameters
	// Now you can access the id parameter as params.id

	return (
		<p>
			This is the user with the id of <code>{params.id}</code>
		</p>
	);
};
```

`useParams` can be especially useful with other Solid primitives, such as [`createResource`](/reference/basic-reactivity/create-resource) and [`createSignal`](/reference/basic-reactivity/create-signal), which can create dynamic behaviors based on the route parameters.

```jsx
import { createResource } from "solid-js";
import { useParams } from "@solidjs/router";

async function fetchUser(id) {
	const response = await fetch(
		`https://jsonplaceholder.typicode.com/users/${id}`
	);
	return response.json();
}

const User = () => {
	const params = useParams();
	const [data] = createResource(() => params.id, fetchUser); // Pass the id parameter to createResource

	return (
		
			
		
	);
};
```

Every time the `id` parameter changes in this example, the `fetchUser` function is called to fetch the new user data.

### Validating routes

Each path parameter can be validated using a `MatchFilter`.
Instead of checking for the presence of a parameter, this allows for more complex routing descriptions:

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route, type MatchFilters } from "@solidjs/router";

const User = lazy(() => import("./pages/User"));

const filters: MatchFilters = {
  parent: ["mom", "dad"], // allow enum values
  id: /^\d+$/, // only allow numbers
  withHtmlExtension: (v: string) => v.length > 5 && v.endsWith(".html"), // only `*.html` extensions wanted
};

render(() => (
  
), document.getElementById("root"));
```

In this example, the `matchFilters` prop provides a way to validate the `parent`, `id` and `withHtmlExtension` parameters against the filters defined in `filters`.
If the validation fails, the route will not match.

In this example:

- `/users/mom/123/contact.html` will match,
- `/users/dad/123/about.html` will match,
- `/users/aunt/123/contact.html` will **not** match as `:parent` is not 'mom' or 'dad',
- `/users/mom/me/contact.html` will **not** match as `:id` is not a number,
- `/users/dad/123/contact` will **not** match as `:withHtmlExtension` is missing `.html`.

### Optional parameters

Parameters can be specified as optional by adding a question mark to the end of the parameter name:

```jsx
// Matches stories and stories/123 but not stories/123/comments

```

### Wildcard routes

To match any descendent routes within a given path, you can use the wildcard token (`*`).
This can be used to represent any value in that segment of the path.

```jsx
// Will match any path beginning with foo (eg. foo/, foo/a/, foo/a/b/c)

```

To expose the wildcard portion to the component as a parameter, you can name it:

```jsx

```

Wildcard tokens **must** be the last part of the path; `foo/*any/bar` will not create any routes.

### Multiple paths

The `Routes` component also supports defining multiple paths using an array.
This avoids a route rerendering when switching between two or more locations that it matches:

```jsx
// Navigating from "/login" to "/register" will not cause the component to re-render

```

## Nested routes

Only leaf `
```

The following two route definitions both match the same URL `/users/:id` and render the same component:

```jsx



```

If you want to make the parent its own route, you have to specify it separately:

```jsx



// or


```

You can also take advantage of nesting by using `props.children` passed to the route component.

```jsx
function PageWrapper(props) {
	return (
		
			<h1> We love our users! </h1>
			{props.children}
			
		
	);
}

;
```

The routes are still configured the same, however now their components will appear inside the parent component where the `props.children` is declared.

Routes can also be nested indefinitely.
This example will only render the route `/layer1/layer2`, which will be nested in 3 divs.

```jsx

</Route>
```

## Preload functions

With preload functions, data fetching is started parallel to loading the route, so it can be used as soon as possible.
The preload function prevents this by being called once the Route is loaded, or eagerly if links are hovered.

As the only argument, the preload function is passed an object that is used to access route information:

```jsx
import { lazy } from "solid-js";
import { Route } from "@solidjs/router";

const User = lazy(() => import("./pages/users/[id].js"));

// preload function
function preloadUser({ params, location }) {
	// do preload
}
```

The preload function is then passed in the `
	),
	document.getElementById("root")
);
```

`[id].jsx` contains the component that gets rendered.
When you wrap the function within [`createAsync`](/solid-router/reference/data-apis/create-async) with the imported function, it will yield [a signal](/concepts/signals) once the anticipated promise resolves.

```tsx title="[id].tsx"
import { createAsync } from "@solidjs/router";
import { getUser } from "./[id].data";

export default function Users(props) {
	console.log("Users.props", props);
	const user = createAsync(() => getUser(props.params.id));
	return (
		<>
			<h1>User</h1>
			
				<pre>{JSON.stringify(user(), null, 2)}</pre>
			
		</>
	);
}
```

To learn more about routing your Solid applications, visit the [Solid Router documentation](/solid-router).